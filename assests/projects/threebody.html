<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ThreebodyProblem</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/glslCanvas@latest/dist/GlslCanvas.js"></script>
  <style>
    html, body {
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      background: #111;
      color: #fff;
      font-family: 'Segoe UI', Arial, sans-serif;
    }
    #glsl-canvas {
      position: fixed;
      left: 0;
      top: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      display: block;
      background: #000;
      pointer-events: none; /* Prevent canvas from blocking interactions */
    }
  </style>
  <link rel="stylesheet" href="../css/pros.css">
</head>
<body>
  <!-- Fullscreen shader canvas as background -->
  <canvas class="glslCanvas" id="glsl-canvas"></canvas>

  <div class="container">
    <!-- Go Back Button -->
    <a href="./project.html" class="nav__link">&uArr; Back</a>
    
    <header>
      <h1>Illustration of 3 Body Problem (Inspiration)</h1>
      <h2>GLSL Shader Example</h2>
    </header>   
    <section>
      <h2>The Shader Code</h2>
      <p>
        The core of this demo is a GLSL fragment shader. You can inspect the code
      </p>
      <pre><code>// See the &lt;script id="fragShader"&gt; tag for the full shader code.</code></pre>
    </section>
  </div>

  <!-- GLSL Shader Script -->
  <script id="fragShader" type="x-shader/x-fragment">
  
    #ifdef GL_ES
    precision highp float;
    #endif

    uniform float u_time;
    uniform vec2 u_resolution;

    #define PI 3.14159265359
    #define grad_step 0.01
    #define iResolution u_resolution
    #define iTime u_time
    #define time (iTime+2.31)

    vec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d) {
        return a + b*cos(6.28318*(c*t+d));
    }

    vec3 spectrum(float n) {
        return pal(n, vec3(0.5), vec3(0.5,0.0,0.5), vec3(1.0), vec3(0.2,0.33,0.67));
    }

    float sdSphere(vec3 p, float s) {
        return length(p) - s;
    }

    float opOnion(float sdf, float thickness) {
        return abs(sdf) - thickness;
    }

    float sdUnion_s(float a, float b, float k) {
        float h = clamp(0.5 + 0.5*(b - a)/k, 0.0, 1.0);
        return mix(b, a, h) - k*h*(1.0 - h);
    }

    vec3 carToPol(vec3 p) {
        float r = length(p);
        float the = acos(p.z / r);
        float phi = atan(p.y, p.x);
        return vec3(r, the, phi);
    }

    mat3 rotationXY(vec2 angle) {
        vec2 c = cos(angle);
        vec2 s = sin(angle);
        return mat3(
            c.y      ,  0.0, -s.y,
            s.y * s.x,  c.x,  c.y * s.x,
            s.y * c.x, -s.x,  c.y * c.x
        );
    }

    float map(vec3 pos) {
        vec3 p2 = vec3(1.0*cos(-0.3*time), 1.4*sin(time)*cos(-0.4*time), 1.7*sin(time)*sin(-0.3*time));
        float d2 = sdSphere(pos - p2, 0.2);
        vec3 p3 = vec3(1.4*sin(0.3*time), 0.2, -1.6*sin(0.3*time + 0.3));
        float d3 = sdSphere(pos - p3, 0.2);
        float d4 = sdSphere(pos, 0.2);
        float d00 = sdUnion_s(d2, d3, 0.2);
        float d0 = sdUnion_s(d00, d4, 0.2);
        vec3 pol = carToPol(pos);
        float d1 = sdSphere(pos, 1.0);
        float wave = 0.07*sin(20.0 * pol.y);
        d1 = opOnion(d1 + wave, 0.001);
        return sdUnion_s(d1, d0, 0.3);
    }

    vec3 gradient(vec3 pos) {
        const vec3 dx = vec3(grad_step, 0.0, 0.0);
        const vec3 dy = vec3(0.0, grad_step, 0.0);
        const vec3 dz = vec3(0.0, 0.0, grad_step);
        return normalize(vec3(
            map(pos + dx) - map(pos - dx),
            map(pos + dy) - map(pos - dy),
            map(pos + dz) - map(pos - dz)
        ));
    }

    vec3 selfColor(vec3 pos) {
        vec3 pol = carToPol(pos);
        return spectrum(1.0 * pol.z / PI / 2.0 + 0.5 * pol.y / PI);
    }

    mat3 calcLookAtMatrix(vec3 ro, vec3 ta, float roll) {
        vec3 ww = normalize(ta - ro);
        vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));
        vec3 vv = normalize(cross(uu, ww));
        return mat3(uu, vv, ww);
    }

    float rCoeff(vec3 p, vec3 rd) {
        vec3 g = gradient(p);
        g = rotationXY(vec2(2.0, 1.0)) * g;
        return 1.0 - dot(g, rd);
    }

    void mainImage(out vec4 fragColor, in vec2 fragCoord) {
        vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;
        vec3 ro = vec3(0.0, 5.0 * cos(0.3 * time), 5.0 * sin(0.3 * time));
        vec3 ta = vec3(0.0);
        float aa = 1.0 / min(iResolution.y, iResolution.x);
        mat3 camMat = calcLookAtMatrix(ro, ta, 1.5);
        vec3 rd = normalize(camMat * vec3(p.xy, 3.0));

        // Use time-driven rotation only
        mat3 rot = rotationXY(vec2(time * 0.1, time * 0.05));
        rd = rot * rd;
        ro = rot * ro;

        vec3 col = vec3(1.0), sp;
        float t = 0.0, layers = 0.0, d, aD;
        float thD = 0.5 * sqrt(aa);

        for (int i = 0; i < 80; i++) {
            if (layers > 10.0 || col.x < 0.0 || t > 8.0) break;
            sp = ro + rd * t;
            d = map(sp);
            aD = (thD - abs(d)) / thD;
            if (aD > 0.0) {
                vec3 sc = selfColor(sp);
                float refl = 0.1 * pow(exp(-4.0 * rCoeff(sp, rd)), 2.0);
                col -= sc * (aD * aD * (3.0 - 2.0 * aD) / (1.0 + t * t * 2.25) * 7.5);
                col += refl;
                layers++;
            }
            t += max(abs(d) * 0.5, thD * 0.8);
        }

        col = max(col, 0.0);    
        fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
    }

    void main() {
        mainImage(gl_FragColor, gl_FragCoord.xy);
    }
  </script>
  <script>
    const canvas = document.getElementById('glsl-canvas');
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const sandbox = new GlslCanvas(canvas);
    sandbox.load(document.getElementById('fragShader').textContent);
  </script>

  <!-- GLSL Canvas Setup Script -->
   <script src="../js/pros.js"></script>
</body>
</html>
