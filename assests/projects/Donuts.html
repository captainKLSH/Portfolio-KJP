<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js Shadertoy</title>
    <link rel="stylesheet" href="../css/pros.css">

    <style>
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
        }
        body {
            min-height: 100vh;
            min-width: 100vw;
            position: relative;
        }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            display: block;
            pointer-events: none;
        }
    </style>
</head>
<body>
  <div class="container">
    <!-- Go Back Button -->
    <a href="./project.html" class="nav__link">&uArr; Back</a>
    
    <header>
        <h1>Illustration of 4th Dimension ToriSpherical chains</h1>
      <h2>GLSL Shader Example</h2>
      
    </header>   
    <section>
      <h2>The Shader Code</h2>
      <p>
        The core of this demo is a GLSL fragment shader. You can inspect the code
      </p>
      <pre><code>// See the &lt;script id="fragShader"&gt; tag for the full shader code.</code></pre>
    </section>
  </div>
    
    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform float iTime;
        uniform vec2 iResolution;
        varying vec2 vUv;

        #define PI 3.14159265359

        void pR(inout vec2 p, float a) {
            p = cos(a)*p + sin(a)*vec2(p.y, -p.x);
        }

        float smax(float a, float b, float r) {
            vec2 u = max(vec2(r + a,r + b), vec2(0));
            return min(-r, max (a, b)) + length(u);
        }

        vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {
            return a + b*cos( 6.28318*(c*t+d) );
        }

        vec3 spectrum(float n) {
            return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );
        }

        vec4 inverseStereographic(vec3 p, out float k) {
            k = 2.0/(1.0+dot(p,p));
            return vec4(k*p,k-1.0);
        }

        float fTorus(vec4 p4) {
            float d1 = length(p4.xy) / length(p4.zw) - 1.;
            float d2 = length(p4.zw) / length(p4.xy) - 1.;
            float d = d1 < 0. ? -d1 : d2;
            d /= PI;
            return d;
        }

        float fixDistance(float d, float k) {
            float sn = sign(d);
            d = abs(d);
            d = d / k * 1.82;
            d += 1.;
            d = pow(d, .5);
            d -= 1.;
            d *= 5./3.;
            d *= sn;
            return d;
        }

        float time;

        float map(vec3 p) {
            float k;
            vec4 p4 = inverseStereographic(p,k);

            pR(p4.zy, time * -PI / 2.);
            pR(p4.xw, time * -PI / 2.);

            float d = fTorus(p4);
            d = abs(d);
            d -= .2;
            d = fixDistance(d, k);
            d = smax(d, length(p) - 1.85, .2);

            return d;
        }

        mat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {
            vec3 ww = normalize(ta - ro);
            vec3 uu = normalize(cross(ww,up));
            vec3 vv = normalize(cross(uu,ww));
            return mat3(uu, vv, ww);
        }

        void mainImage(out vec4 fragColor, in vec2 fragCoord) {
            time = mod(iTime / 2., 1.);

            vec3 camPos = vec3(1.8, 5.5, -5.5) * 1.75;
            vec3 camTar = vec3(.0,0,.0);
            vec3 camUp = vec3(-1,0,-1.5);
            mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);
            float focalLength = 5.;
            vec2 p = (-iResolution.xy + 2. * fragCoord) / iResolution.y;

            vec3 rayDirection = normalize(camMat * vec3(p, focalLength));
            vec3 rayPosition = camPos;
            float rayLength = 0.;

            float distance = 0.;
            vec3 color = vec3(0);

            vec3 c;

            const float ITER = 82.;
            const float FUDGE_FACTORR = .8;
            const float INTERSECTION_PRECISION = .001;
            const float MAX_DIST = 20.;

            for (float i = 0.; i < ITER; i++) {
                rayLength += max(INTERSECTION_PRECISION, abs(distance) * FUDGE_FACTORR);
                rayPosition = camPos + rayDirection * rayLength;
                distance = map(rayPosition);

                c = vec3(max(0., .01 - abs(distance)) * .5);
                c *= vec3(1.4,2.1,1.7);

                c += vec3(.6,.25,.7) * FUDGE_FACTORR / 160.;
                c *= smoothstep(20., 7., length(rayPosition));

                float rl = smoothstep(MAX_DIST, .1, rayLength);
                c *= rl;

                c *= spectrum(rl * 6. - .6);

                color += c;

                if (rayLength > MAX_DIST) {
                    break;
                }
            }

            color = pow(color, vec3(1. / 1.8)) * 2.;
            color = pow(color, vec3(2.)) * 3.;
            color = pow(color, vec3(1. / 2.2));

            fragColor = vec4(color, 1);
        }

        void main() {
            vec4 fragColor;
            mainImage(fragColor, gl_FragCoord.xy);
            gl_FragColor = fragColor;
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script>
        // Uniforms
        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
        };

        // Shader Material
        const material = new THREE.ShaderMaterial({
            uniforms,
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent
        });

        // Fullscreen quad
        const geometry = new THREE.PlaneGeometry(2, 2);
        const mesh = new THREE.Mesh(geometry, material);

        // Scene & Camera
        const scene = new THREE.Scene();
        scene.add(mesh);
        const camera = new THREE.Camera();

        // Renderer
        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Animation loop
        function animate() {
            uniforms.iTime.value = performance.now() / 1000;
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate();

        // Responsive
        window.addEventListener('resize', () => {
            uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
    <script src="../js/pros.js"></script>
</body>
</html>
