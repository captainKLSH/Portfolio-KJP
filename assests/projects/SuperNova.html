<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebGL Nebula Shader Demo</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #fff; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <h1>3D SuperNova </h1>
<canvas id="glcanvas"></canvas>
<script type="module">
// Vertex shader (simple passthrough)
const vertSource = `
attribute vec2 position;
varying vec2 vUv;
void main() {
  vUv = position * 0.5 + 0.5;
  gl_Position = vec4(position, 0, 1);
}`;

// Your fragment shader, adapted for WebGL
const fragSource = `#ifdef GL_ES
precision highp float;
#endif

#define ITERATIONS 70
#define pi 3.14159265
#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)

uniform float iTime;
uniform vec3 iResolution;
uniform vec4 iMouse;
uniform sampler2D iChannel0;

varying vec2 vUv;

// ... (rest of your shader code, copy/paste unchanged except:)
// Replace "void mainImage( out vec4 fragColor, in vec2 fragCoord )" with:
void mainImage( out vec4 fragColor, in vec2 fragCoord );

// Then add:
void main() {
  vec4 color = vec4(0.0);
  mainImage(color, gl_FragCoord.xy);
  gl_FragColor = color;
}

// ---- Paste your mainImage() and all functions here ----

// (Paste your mainImage and all functions exactly as in your code above)
float length2( vec2 p ) {
	return sqrt( p.x*p.x + p.y*p.y );
}
float length8( vec2 p ) {
	p = p*p; p = p*p; p = p*p;
	return pow( p.x + p.y, 1.0/8.0 );
}
mat4 rotate(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}
float noise( in vec3 x ) {
    vec3 p = floor(x);
    vec3 f = fract(x);
	f = f*f*(3.0-2.0*f);
	vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
	vec2 rg = texture2D( iChannel0, (uv+ 0.5)/256.0 ).yx;
	return 1. - 0.82*mix( rg.x, rg.y, f.z );
}
float fbm(vec3 p) {
   return noise(p*.04125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;
}
float Disk( vec3 p, vec3 t ) {
    vec2 q = vec2(length2(p.xy) -t.x,p.z*0.7);
    return max(length8(q)-t.y, abs(p.z) - t.z);
}
const float nudge = 0.9;
float normalizer = 1.0 / sqrt(1.0 + nudge*nudge);
float SpiralNoiseC(vec3 p) {
    float n = 0.0;
    float iter = 2.0;
    for (int i = 0; i < 8; i++)
    {
        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;
        p.xy += vec2(p.y, -p.x) * nudge;
        p.xy *= normalizer;
        p.xz += vec2(p.z, -p.x) * nudge;
        p.xz *= normalizer;
        iter *= 1.733733;
    }
    return n;
}
float NebulaNoise(vec3 p) {
    float final = Disk(p.xzy,vec3(2.0,2.0,0.3));
    final += fbm(p*60.0);
    final += SpiralNoiseC(p.zxy*0.7+1.6)*2.0;
    return final;
}
float map(vec3 p) {
	R(p.xz, iMouse.x*0.008*pi+iTime*0.1);
    p = (vec4(p,1.0) * rotate(vec3(1.0, 0.0, 0.0), pi / 4.0)).rgb;
	float NebNoise = abs(NebulaNoise(p/0.5)*0.5);
	return NebNoise+0.07;
}
vec3 computeColor( float density, float radius )
{
	vec3 result = mix( vec3(1.0), vec3(0.5), density );
	vec3 colCenter = 7.*vec3(0.8,0.9,1.0).rgb;
	vec3 colEdge = 1.5*vec3(0.48,0.53,0.5).rgb;
	result *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );
	return result;
}
bool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)
{
	float b = dot(dir, org);
	float c = dot(org, org) - 10.0;
	float delta = b*b - c;
	if( delta < 0.0)
		return false;
	float deltasqrt = sqrt(delta);
	near = -b - deltasqrt;
	far = -b + deltasqrt;
	return far > 0.0;
}
void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    float zoom = (iMouse.y / iResolution.y) * 2.0;
	vec3 rd = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));
	vec3 ro = vec3(0., 0., -6.0 + (5.0 * zoom));
	float ld=0., td=0., w=0.;
	float d=1., t=0.;
    const float h = 0.1;
	vec4 sum = vec4(0.0);
    float min_dist=0.0, max_dist=0.0;
    if(RaySphereIntersect(ro, rd, min_dist, max_dist))
    {
	t = min_dist*step(t,min_dist);
	for (int i=0; i<ITERATIONS; i++) {
		vec3 pos = ro + t*rd;
	    if(td>0.9 || t>20. || sum.a > 0.99 || t>max_dist) break;
        float d = map(pos);
		d = max(d,0.0);
        vec3 ldst = vec3(0.0)-pos;
        float lDist = max(length(ldst), 0.001);
        float _T = lDist*2.3+2.6;
        vec3 lightColor=0.4+0.5*cos(_T + pi * 0.5*vec3(-0.5,0.05,0.5));
        sum.rgb+=(vec3(0.57,1.85,1.00)/(lDist*lDist*10.)/70.0);
        sum.rgb+=(lightColor/exp(lDist*lDist*lDist*.05)/30.0);
		if (d<h) {
			ld = h - d;
			w = (1. - td) * ld;
			td += w + 1./200.;
			vec4 col = vec4( computeColor(td,lDist), td );
            sum += sum.a * vec4(sum.rgb, 0.0) * 0.2;
			col.a *= 0.2;
			col.rgb *= col.a;
			sum = sum + col*(1.0 - sum.a);
		}
		td += 1./70.;
        t += max(d * 0.1 * max(min(length(ldst),length(ro)),1.0), 0.01);
	}
	sum *= 1. / exp( ld * 0.2 ) * 0.6;
   	sum = clamp( sum, 0.0, 1.0 );
    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);
	}
    fragColor = vec4(sum.xyz,1.0);
}
`;

// Utility: create a small RG noise texture (like Shadertoy's iChannel0)
function createNoiseTexture(gl) {
  const size = 256;
  const data = new Uint8Array(size * size * 4);
  for (let i = 0; i < size * size * 4; ++i) data[i] = Math.floor(Math.random() * 256);
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  return tex;
}

// --- WebGL setup ---
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl');
if (!gl) throw new Error('WebGL not supported');

// Compile shader
function compile(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    throw new Error(gl.getShaderInfoLog(shader));
  return shader;
}
const vs = compile(gl.VERTEX_SHADER, vertSource);
const fs = compile(gl.FRAGMENT_SHADER, fragSource);

// Link program
const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);
if (!gl.getProgramParameter(prog, gl.LINK_STATUS))
  throw new Error(gl.getProgramInfoLog(prog));
gl.useProgram(prog);

// Set up vertex buffer (full-screen quad)
const posLoc = gl.getAttribLocation(prog, 'position');
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1,  1,-1,  -1,1,  1,1
]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

// Uniform locations
const iTimeLoc = gl.getUniformLocation(prog, 'iTime');
const iResLoc = gl.getUniformLocation(prog, 'iResolution');
const iMouseLoc = gl.getUniformLocation(prog, 'iMouse');
const iChannel0Loc = gl.getUniformLocation(prog, 'iChannel0');

// Upload noise texture
const noiseTex = createNoiseTexture(gl);
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, noiseTex);
gl.uniform1i(iChannel0Loc, 0);

// Mouse handling
let mouse = [0, 0, 0, 0];
let dragging = false;
canvas.addEventListener('mousedown', e => { dragging = true; mouse[2] = 1; });
canvas.addEventListener('mouseup', e => { dragging = false; mouse[2] = 0; });
canvas.addEventListener('mousemove', e => {
  if (dragging) {
    mouse[0] = e.offsetX;
    mouse[1] = canvas.height - e.offsetY;
  }
});
canvas.addEventListener('mouseleave', e => { dragging = false; mouse[2] = 0; });

// Resize
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

// Animation loop
function render(time) {
  gl.useProgram(prog);
  gl.uniform1f(iTimeLoc, time * 0.001);
  gl.uniform3f(iResLoc, canvas.width, canvas.height, 1);
  gl.uniform4fv(iMouseLoc, mouse);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
